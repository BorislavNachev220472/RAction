import numpy as np
import skimage.feature
import skimage.measure
import skimage.morphology

import SimpleITK as sitk

from scipy import ndimage
from concurrent.futures import ThreadPoolExecutor

from specifix.segmentation.cli.config import Config
from specifix.segmentation.cli.converter import Converter
from specifix.segmentation.cli.io import BoneIOFileManager


class Shell(BoneIOFileManager):

    def __init__(self, input_directory: str, output_directory: str, reference_filename: str):
        super().__init__(input_directory, output_directory)
        self.Converter = Converter(reference_filename)

    def perform_morphological_closing(self, mask: sitk.Image, iterations: int = 5):
        """Perform morphological closing (dilation followed by erosion) on the mask."""
        # Increase the structuring element size to connect more features
        dilated_mask = skimage.morphology.binary_dilation(mask, footprint=skimage.morphology.disk(1))

        for _ in range(iterations):
            dilated_mask = skimage.morphology.binary_dilation(dilated_mask, footprint=skimage.morphology.disk(1))

        closed_mask = dilated_mask
        for _ in range(iterations):
            closed_mask = skimage.morphology.binary_erosion(closed_mask, footprint=skimage.morphology.disk(1))

        return closed_mask

    def thicken_boundary(self, mask: sitk.Image, iterations: int = 1):
        """Thicken boundary lines to avoid breaking during erosion."""
        thickened = mask
        for _ in range(iterations):
            thickened = skimage.morphology.binary_dilation(thickened, footprint=skimage.morphology.disk(1))
        return thickened

    def remove_inner_artifacts(self, mask: sitk.Image):
        """Remove any small internal artifacts that may remain inside the object."""
        labeled_mask, num_features = ndimage.label(mask)

        if num_features == 0:
            # Return the original mask if no features are found
            return mask

        sizes = ndimage.sum(mask, labeled_mask, range(num_features + 1))

        if len(sizes) <= 1:
            # If no valid components were found, return the original mask
            return mask

        # Consider only the largest connected component as the outer boundary
        largest_component = sizes[1:].argmax() + 1
        cleaned_mask = np.where(labeled_mask == largest_component, 1, 0)

        return cleaned_mask

    def extract_outer_boundary(self, mask: np.array):
        """Extract only the outer boundary of the object, ignoring any internal edges."""
        # Create a binary mask by filling holes
        filled_mask = ndimage.binary_fill_holes(mask)

        # Perform morphological closing to smooth and expand the boundaries
        closed_mask = self.perform_morphological_closing(filled_mask, iterations=1)

        # Remove any inner artifacts that might remain
        cleaned_mask = self.remove_inner_artifacts(closed_mask)

        # Subtract the eroded mask from the closed mask to get only the outer boundary
        eroded_mask = skimage.morphology.binary_erosion(cleaned_mask, footprint=skimage.morphology.disk(1))
        outer_boundary = cleaned_mask & ~eroded_mask
        outer_boundary = self.thicken_boundary(outer_boundary, iterations=1)

        return outer_boundary

    def process_single_mask(self, mask: sitk.Image, filename: str):
        """
        This function converts each nrrd to its slices and applies the shell algorithm on eahc slice.
        :param mask: sitk.Image representing the current nrrd.
        :param filename: str ussed to filter junk files generated by the labeling software.
        :return: None/processed slices and the sitk.Image object.
        """
        if not any(keyword in filename.lower() for keyword in
                   ["cyan", "green", "cl", "small", "region b", "radius", "yellow"]):
            mask_size = mask.GetSize()
            processed_slices = np.zeros((mask_size[2], mask_size[1], mask_size[0]), dtype=np.uint8)

            for i in range(mask_size[2]):
                mask_slice = mask[:, :, i]
                processed_slice = self.extract_outer_boundary(self.Converter.get_array_from_image(mask_slice))
                processed_slices[i, :, :] = np.uint8(processed_slice)

            return processed_slices, mask
        return None, None

    def process_ct_scan(self, ct_scan: str, labels_output_path: str):
        """
        This function generates a shell for a single CT scan. It loops through the nrrds and generates a nifti file
        with their shelled version.
        The CT scan should be stored in the following way:
        CT_SCAN_NAME
            - nrrd
                - *files*
        :param ct_scan: str the name of folder of the CT scan that contains its nrrds.
        :param labels_output_path: str the output name of the generated nifti file.
        :return: None
        """
        mask_filenames = iter(f for f in self.set_inner_folder(ct_scan)
                              .set_inner_folder(Config.NRRD_INNER_DIRECTORY)
                              .read_all() if f.endswith(Config.NRRD_EXTENSION))

        final_mask_array = None
        with ThreadPoolExecutor() as executor:
            futures = [executor.submit(self.process_single_mask, (self.set_inner_folder(ct_scan)
                                                                  .set_inner_folder(Config.NRRD_INNER_DIRECTORY))
                                       .read_file(filename), filename) for filename in mask_filenames]

            for future in futures:
                processed_slices, mask = future.result()
                if final_mask_array is None:
                    final_mask_array = processed_slices
                else:
                    final_mask_array = np.logical_or(final_mask_array, processed_slices)

        if final_mask_array is not None:
            final_mask_array = np.uint8(final_mask_array)
            final_mask = self.Converter.get_image_from_array(final_mask_array)
            final_mask.SetSpacing(self.Converter.reference_image.GetSpacing())
            final_mask.SetOrigin(self.Converter.reference_image.GetOrigin())
            final_mask.SetDirection(self.Converter.reference_image.GetDirection())

            self.save_file(image=final_mask, file_name=labels_output_path)
            print(f"Processed mask saved to {labels_output_path}")
